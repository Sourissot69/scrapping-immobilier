#!/usr/bin/env python3
"""
Script complet SeLoger : Gestion banni√®re cookies + Recherche Saumur + R√©cup√©ration annonces
"""

import time
import logging
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException, WebDriverException
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.action_chains import ActionChains
import undetected_chromedriver as uc
import json
import argparse
from datetime import datetime

# Supabase
try:
    from supabase import create_client, Client
    SUPABASE_AVAILABLE = True
except ImportError:
    print("‚ö†Ô∏è  Supabase non install√©. Utilisez: pip install supabase")
    SUPABASE_AVAILABLE = False

# Configuration du logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class SupabaseManager:
    """Gestionnaire pour les interactions avec Supabase"""
    
    def __init__(self, supabase_url: str = None, supabase_key: str = None):
        self.supabase_url = supabase_url
        self.supabase_key = supabase_key
        self.supabase = None
        self.current_campaign_id = None
        
        if supabase_url and supabase_key and SUPABASE_AVAILABLE:
            self.setup_supabase()
    
    def setup_supabase(self):
        """Configure la connexion Supabase"""
        try:
            self.supabase = create_client(self.supabase_url, self.supabase_key)
            logger.info("‚úÖ Connexion Supabase √©tablie")
            return True
        except Exception as e:
            logger.error(f"‚ùå Erreur connexion Supabase: {e}")
            return False
    
    def create_search_campaign(self, search_config: dict, search_url: str):
        """Cr√©e une nouvelle campagne de scraping dans Supabase"""
        if not self.supabase:
            return None
        
        try:
            # Obtenir l'ID de la source SeLoger
            source_result = self.supabase.table('sources').select('id').eq('name', 'seloger').execute()
            
            if not source_result.data:
                logger.error("‚ùå Source SeLoger non trouv√©e dans la base")
                return None
            
            source_id = source_result.data[0]['id']
            
            # Cr√©er la campagne
            campaign_data = {
                'source_id': source_id,
                'search_config': search_config,
                'search_url': search_url,
                'status': 'running',
                'started_at': datetime.now().isoformat()
            }
            
            result = self.supabase.table('search_campaigns').insert(campaign_data).execute()
            
            if result.data:
                self.current_campaign_id = result.data[0]['id']
                logger.info(f"‚úÖ Campagne Supabase cr√©√©e: {self.current_campaign_id}")
                return self.current_campaign_id
            else:
                logger.error("‚ùå Erreur cr√©ation campagne")
                return None
                
        except Exception as e:
            logger.error(f"‚ùå Erreur cr√©ation campagne: {e}")
            return None
    
    def send_listings_to_supabase(self, listings: list):
        """Envoie les annonces vers Supabase (ID + URL uniquement)"""
        if not self.supabase or not self.current_campaign_id:
            return False
        
        try:
            # Obtenir l'ID de la source SeLoger
            source_result = self.supabase.table('sources').select('id').eq('name', 'seloger').execute()
            source_id = source_result.data[0]['id'] if source_result.data else None
            
            if not source_id:
                logger.error("‚ùå Source SeLoger non trouv√©e")
                return False
            
            success_count = 0
            
            for listing in listings:
                try:
                    # Pr√©parer les donn√©es minimales pour la table listings
                    listing_data = {
                        'campaign_id': self.current_campaign_id,
                        'source_id': source_id,
                        'listing_id': listing.get('id', ''),
                        'url': listing.get('url', ''),
                        'scraped_at': datetime.now().isoformat(),
                        'needs_detail_scraping': True
                    }
                    
                    # Ins√©rer dans la table listings
                    result = self.supabase.table('listings').insert(listing_data).execute()
                    
                    if result.data:
                        logger.info(f"   ‚úÖ Annonce sauv√©e: ID {listing.get('id', 'N/A')}")
                        success_count += 1
                    else:
                        logger.error(f"   ‚ùå Erreur sauvegarde: ID {listing.get('id', 'N/A')}")
                        
                except Exception as e:
                    logger.error(f"   ‚ùå Erreur annonce: {e}")
                    continue
            
            logger.info(f"üìä {success_count}/{len(listings)} annonces sauvegard√©es dans Supabase")
            return success_count > 0
            
        except Exception as e:
            logger.error(f"‚ùå Erreur envoi vers Supabase: {e}")
            return False
    
    def update_campaign_status(self, status: str, total_pages: int = 0, total_listings: int = 0):
        """Met √† jour le statut de la campagne"""
        if not self.supabase or not self.current_campaign_id:
            return False
        
        try:
            update_data = {
                'status': status,
                'total_pages': total_pages,
                'total_listings_found': total_listings
            }
            
            if status == 'completed':
                update_data['completed_at'] = datetime.now().isoformat()
            
            self.supabase.table('search_campaigns').update(update_data).eq('id', self.current_campaign_id).execute()
            logger.info(f"‚úÖ Campagne mise √† jour: {status}")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erreur mise √† jour campagne: {e}")
            return False

def setup_driver(headless: bool = True):
    """Configure et retourne le driver Chrome avec les bonnes options"""
    try:
        options = Options()
        
        if headless:
            options.add_argument("--headless")
            logger.info("üîá Mode invisible activ√©")
        else:
            options.add_argument("--start-maximized")
            logger.info("üëÅÔ∏è Mode visible activ√©")
            
        options.add_argument("--disable-blink-features=AutomationControlled")
        options.add_argument("--disable-web-security")
        options.add_argument("--allow-running-insecure-content")
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")
        
        # Utiliser undetected-chromedriver
        driver = uc.Chrome(options=options, version_main=None)
        
        # Masquer les indicateurs d'automatisation
        driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
        
        return driver
    except Exception as e:
        logger.error(f"Erreur lors de la configuration du driver: {e}")
        return None

def load_cookies(driver, cookie_file):
    """Charge les cookies depuis un fichier (version simplifi√©e)"""
    try:
        with open(cookie_file, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        
        cookies_loaded = 0
        for line in lines:
            line = line.strip()
            if line and not line.startswith('#'):
                parts = line.split('\t')
                if len(parts) >= 7:
                    try:
                        # V√©rifier que le domaine correspond
                        domain = parts[0]
                        if 'seloger.com' in domain:
                            cookie = {
                                'name': parts[5],
                                'value': parts[6],
                                'domain': domain if domain.startswith('.') else f'.{domain}',
                                'path': parts[2] if parts[2] else '/',
                                'secure': parts[3].lower() == 'true'
                            }
                            driver.add_cookie(cookie)
                            cookies_loaded += 1
                    except Exception as e:
                        logger.warning(f"Cookie ignor√©: {e}")
        
        logger.info(f"‚úÖ {cookies_loaded} cookies charg√©s avec succ√®s")
        return True
    except Exception as e:
        logger.error(f"Erreur lors du chargement des cookies: {e}")
        return False

def handle_cookie_banner(driver):
    """G√®re la banni√®re de cookies Usercentrics"""
    logger.info("üç™ Gestion de la banni√®re de cookies...")
    
    try:
        # Attendre que la page soit charg√©e (r√©duit de 3 √† 1 seconde)
        time.sleep(1)
        
        # Script pour cliquer sur "Tout accepter" dans le Shadow DOM
        script = """
        var host = document.querySelector('#usercentrics-root');
        if (host && host.shadowRoot) {
            var button = host.shadowRoot.querySelector('[data-testid="uc-accept-all-button"]');
            if (button) {
                button.click();
                return true;
            }
        }
        return false;
        """
        
        success = driver.execute_script(script)
        
        if success:
            logger.info("‚úÖ Banni√®re de cookies accept√©e")
            time.sleep(1)  # R√©duit de 2 √† 1 seconde
            return True
        else:
            logger.warning("‚ö†Ô∏è Banni√®re de cookies non trouv√©e ou d√©j√† ferm√©e")
            return True  # Continuer m√™me si pas de banni√®re
            
    except Exception as e:
        logger.error(f"Erreur lors de la gestion de la banni√®re: {e}")
        return True  # Continuer m√™me en cas d'erreur

def handle_alert_popup(driver):
    """G√®re la pop-up d'alerte qui peut appara√Ætre"""
    logger.info("üîî V√©rification des pop-ups d'alerte...")
    
    try:
        # Attendre un peu pour que la pop-up se charge si elle doit appara√Ætre
        time.sleep(0.5)
        
        # S√©lecteurs pour d√©tecter la pop-up d'alerte
        popup_selectors = [
            'div:contains("Acc√©l√©rez votre recherche")',
            'div:contains("Cr√©er une alerte")', 
            '[role="dialog"]',
            '.modal',
            '.popup'
        ]
        
        # S√©lecteurs pour fermer la pop-up (croix X)
        close_selectors = [
            'button[aria-label="Fermer"]',
            'button[aria-label="Close"]', 
            'button[aria-label="Fermer la modal"]',
            'button.close',
            '.modal-close',
            '.popup-close',
            '[data-testid*="close"]',
            '[aria-label*="fermer"]',
            '[aria-label*="close"]',
            'svg[aria-label="Fermer"]',
            'svg[aria-label="Close"]'
        ]
        
        # V√©rifier si une pop-up est pr√©sente
        popup_found = False
        for selector in popup_selectors:
            try:
                if ':contains(' in selector:
                    # Utiliser XPath pour :contains
                    xpath_selector = "//div[contains(text(), 'Acc√©l√©rez votre recherche') or contains(text(), 'Cr√©er une alerte')]"
                    elements = driver.find_elements(By.XPATH, xpath_selector)
                else:
                    elements = driver.find_elements(By.CSS_SELECTOR, selector)
                
                if elements:
                    for element in elements:
                        if element.is_displayed():
                            popup_found = True
                            logger.info("üîî Pop-up d'alerte d√©tect√©e")
                            break
            except:
                continue
            
            if popup_found:
                break
        
        if not popup_found:
            logger.info("‚ÑπÔ∏è Aucune pop-up d'alerte d√©tect√©e")
            return True
        
        # Essayer de fermer la pop-up
        for selector in close_selectors:
            try:
                buttons = driver.find_elements(By.CSS_SELECTOR, selector)
                
                if buttons:
                    for button in buttons:
                        if button.is_displayed() and button.is_enabled():
                            button.click()
                            logger.info("‚úÖ Pop-up d'alerte ferm√©e")
                            time.sleep(1)
                            return True
            except Exception as e:
                continue
        
        # Si aucun bouton de fermeture n'est trouv√©, essayer d'appuyer sur Escape
        logger.info("üîÑ Tentative de fermeture avec la touche Escape...")
        driver.find_element(By.TAG_NAME, 'body').send_keys(Keys.ESCAPE)
        time.sleep(1)
        
        logger.info("‚úÖ Tentative de fermeture de la pop-up effectu√©e")
        return True
        
    except Exception as e:
        logger.error(f"Erreur lors de la gestion de la pop-up d'alerte: {e}")
        return True  # Continuer m√™me en cas d'erreur

def search_saumur(driver):
    """Recherche la ville de Saumur"""
    logger.info("üè† Recherche de Saumur...")
    
    # Diff√©rents s√©lecteurs possibles pour le champ de recherche
    search_selectors = [
        'input[placeholder*="Saisir le lieu"]',
        'input[placeholder*="lieu ou le code postal"]',
        'input[name="location"]',
        'input[data-testid="location-input"]',
        '.css-rbpmd input',
        '#location-input',
        '[data-cy="location-input"]',
        'input[type="text"]'
    ]
    
    for selector in search_selectors:
        try:
            logger.info(f"üîç Tentative avec le s√©lecteur: {selector}")
            
            # Attendre que l'√©l√©ment soit pr√©sent et visible (r√©duit de 10 √† 5 secondes)
            element = WebDriverWait(driver, 5).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, selector))
            )
            
            # Cliquer sur le champ pour le focus
            element.click()
            time.sleep(0.5)  # R√©duit de 1 √† 0.5 seconde
            
            # Effacer le contenu existant
            element.clear()
            time.sleep(0.2)  # R√©duit de 0.5 √† 0.2 seconde
            
            # Saisir "Saumur"
            element.send_keys("Saumur")
            logger.info("‚úÖ 'Saumur' saisi dans le champ de recherche")
            time.sleep(1)  # R√©duit de 2 √† 1 seconde
            
            # Appuyer sur Entr√©e pour valider
            element.send_keys(Keys.RETURN)
            logger.info("‚å®Ô∏è Touche Entr√©e press√©e pour valider la recherche")
            time.sleep(2)  # R√©duit de 3 √† 2 secondes
            
            return True
                
        except TimeoutException:
            logger.warning(f"‚è∞ Timeout avec le s√©lecteur: {selector}")
            continue
        except Exception as e:
            logger.error(f"‚ùå Erreur avec le s√©lecteur {selector}: {e}")
            continue
    
    logger.error("‚ùå Impossible de trouver le champ de recherche")
    return False

def wait_for_results(driver):
    """Attend que les r√©sultats de recherche se chargent"""
    logger.info("‚è≥ Attente des r√©sultats de recherche...")
    
    try:
        # Attendre que l'URL change ou que des r√©sultats apparaissent (r√©duit de 15 √† 8 secondes)
        WebDriverWait(driver, 8).until(
            lambda d: "saumur" in d.current_url.lower() or 
                     len(d.find_elements(By.CSS_SELECTOR, '[data-testid*="classified-card-mfe"]')) > 0
        )
        
        logger.info(f"‚úÖ R√©sultats charg√©s - URL: {driver.current_url}")
        return True
        
    except TimeoutException:
        logger.warning("‚è∞ Timeout lors de l'attente des r√©sultats")
        logger.info(f"URL actuelle: {driver.current_url}")
        return False

def scroll_and_collect_listings(driver, max_scrolls=30):
    """Navigue par pagination et r√©cup√®re toutes les annonces"""
    logger.info("üìú D√©but de la navigation par pagination et de la r√©cup√©ration des annonces...")
    
    all_listings = []
    page_number = 1
    max_pages = 999  # Pas de limite, on va jusqu'au bout
    
    while page_number <= max_pages:
        try:
            logger.info(f"üîÑ Page {page_number}/{max_pages}")
            
            # Attendre que la page se charge compl√®tement
            time.sleep(1)
            
            # G√©rer une √©ventuelle pop-up d'alerte sur cette page
            handle_alert_popup(driver)
            
            # R√©cup√©rer les annonces de la page actuelle
            try:
                elements = driver.find_elements(
                    By.CSS_SELECTOR, 
                    '[data-testid*="classified-card-mfe"]'
                )
                logger.info(f"‚úÖ Trouv√© {len(elements)} √©l√©ments avec le s√©lecteur: [data-testid*=\"classified-card-mfe\"]")
                
                # Extraire les donn√©es de chaque annonce
                new_listings = []
                for element in elements:
                    listing_data = extract_listing_data_fast(element)
                    if listing_data:
                        # √âviter les doublons
                        if not any(existing.get('url') == listing_data.get('url') for existing in all_listings):
                            new_listings.append(listing_data)
                
                if new_listings:
                    all_listings.extend(new_listings)
                    logger.info(f"üìä {len(new_listings)} nouvelles annonces r√©cup√©r√©es (Total: {len(all_listings)})")
                else:
                    logger.info("‚ÑπÔ∏è Aucune nouvelle annonce trouv√©e sur cette page")
                
            except Exception as e:
                logger.error(f"Erreur lors de la r√©cup√©ration des annonces: {e}")
            
            # Chercher le bouton "Page suivante" ou "Suivant"
            next_button = None
            next_selectors = [
                'a[aria-label*="suivant"]',
                'a[aria-label*="Suivant"]', 
                'a[aria-label*="next"]',
                'a[aria-label*="Next"]',
                'button[aria-label*="suivant"]',
                'button[aria-label*="Suivant"]',
                '[data-testid*="next"]',
                '[data-testid*="suivant"]',
                '.pagination a[rel="next"]',
                '.pagination .next',
                'a:contains("Suivant")',
                'button:contains("Suivant")',
                'a[title*="suivant"]',
                'a[title*="Suivant"]'
            ]
            
            logger.info("üîç Recherche du bouton 'Page suivante'...")
            
            for selector in next_selectors:
                try:
                    if ':contains(' in selector:
                        # Utiliser XPath pour :contains
                        xpath_selector = f"//a[contains(text(), 'Suivant')] | //button[contains(text(), 'Suivant')]"
                        buttons = driver.find_elements(By.XPATH, xpath_selector)
                    else:
                        buttons = driver.find_elements(By.CSS_SELECTOR, selector)
                    
                    if buttons:
                        for button in buttons:
                            # V√©rifier si le bouton est visible et cliquable
                            if button.is_displayed() and button.is_enabled():
                                # V√©rifier qu'il ne s'agit pas d'un bouton d√©sactiv√©
                                class_name = button.get_attribute('class') or ''
                                if 'disabled' not in class_name and 'inactive' not in class_name:
                                    next_button = button
                                    logger.info(f"‚úÖ Bouton 'Page suivante' trouv√© avec le s√©lecteur: {selector}")
                                    break
                    
                    if next_button:
                        break
                        
                except Exception as e:
                    continue
            
            # Si aucun bouton "suivant" n'est trouv√©, essayer de d√©tecter les num√©ros de page
            if not next_button:
                logger.info("üîç Recherche des num√©ros de page...")
                try:
                    # Chercher la page suivante (num√©ro + 1)
                    next_page_num = page_number + 1
                    page_selectors = [
                        f'a[aria-label="Page {next_page_num}"]',
                        f'a:contains("{next_page_num}")',
                        f'button:contains("{next_page_num}")',
                        f'[data-page="{next_page_num}"]'
                    ]
                    
                    for selector in page_selectors:
                        try:
                            if ':contains(' in selector:
                                xpath_selector = f"//a[contains(text(), '{next_page_num}')] | //button[contains(text(), '{next_page_num}')]"
                                buttons = driver.find_elements(By.XPATH, xpath_selector)
                            else:
                                buttons = driver.find_elements(By.CSS_SELECTOR, selector)
                            
                            if buttons:
                                for button in buttons:
                                    if button.is_displayed() and button.is_enabled():
                                        next_button = button
                                        logger.info(f"‚úÖ Page {next_page_num} trouv√©e")
                                        break
                            
                            if next_button:
                                break
                        except:
                            continue
                            
                except Exception as e:
                    logger.error(f"Erreur lors de la recherche des num√©ros de page: {e}")
            
            # Si un bouton est trouv√©, cliquer dessus
            if next_button:
                try:
                    # Scroller vers le bouton pour s'assurer qu'il est visible
                    driver.execute_script("arguments[0].scrollIntoView(true);", next_button)
                    time.sleep(0.5)
                    
                    # Fermer toute pop-up qui pourrait g√™ner
                    handle_alert_popup(driver)
                    
                    # Essayer d'abord un clic normal
                    logger.info(f"üëÜ Clic sur le bouton 'Page suivante'...")
                    try:
                        next_button.click()
                    except Exception as click_error:
                        logger.warning(f"‚ö†Ô∏è Clic normal √©chou√©: {click_error}")
                        # Essayer un clic JavaScript si le clic normal √©choue
                        logger.info("üîÑ Tentative de clic JavaScript...")
                        driver.execute_script("arguments[0].click();", next_button)
                    
                    # Attendre le chargement de la nouvelle page
                    time.sleep(2)
                    page_number += 1
                    logger.info(f"‚úÖ Navigation vers page {page_number} r√©ussie")
                    
                except Exception as e:
                    logger.error(f"‚ùå Erreur lors du clic sur le bouton suivant: {e}")
                    logger.info("üîÑ Tentative de continuer malgr√© l'erreur...")
                    break
            else:
                logger.info("üîö Aucun bouton 'Page suivante' trouv√© - fin de la pagination")
                break
                
        except Exception as e:
            logger.error(f"Erreur sur la page {page_number}: {e}")
            break
    
    logger.info(f"üéØ Navigation termin√©e: {len(all_listings)} annonces au total sur {page_number-1} pages")
    return all_listings

def extract_listing_data_fast(element):
    """Version rapide d'extraction : URL + ID uniquement"""
    try:
        # URL de l'annonce (lien principal)
        try:
            link_elem = element.find_element(By.CSS_SELECTOR, 'a')
            url = link_elem.get_attribute('href')
            if url:
                # Extraire l'ID depuis l'URL
                import re
                id_patterns = [
                    r'/(\d+)\.htm',  # URLs SeLoger classiques
                    r'/detail/(\d+)',  # URLs SeLoger-Construire
                    r'/(\d+)/detail\.htm'  # URLs BellesDemeures
                ]
                
                listing_id = None
                for pattern in id_patterns:
                    match = re.search(pattern, url)
                    if match:
                        listing_id = match.group(1)
                        break
                
                # Si aucun pattern ne correspond, essayer d'extraire n'importe quel nombre long
                if not listing_id:
                    numbers = re.findall(r'\d{8,}', url)
                    if numbers:
                        listing_id = numbers[0]
                
                if listing_id:
                    return {
                        "url": url,
                        "id": listing_id
                    }
        except:
            pass
        
        return None
        
    except Exception as e:
        return None

def save_listings_to_file(listings, filename="saumur_listings.json"):
    """Sauvegarde les annonces dans un fichier JSON"""
    try:
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(listings, f, ensure_ascii=False, indent=2)
        
        logger.info(f"üíæ {len(listings)} annonces sauvegard√©es dans {filename}")
        return True
        
    except Exception as e:
        logger.error(f"Erreur lors de la sauvegarde: {e}")
        return False

def main():
    """Fonction principale"""
    # Gestion des arguments
    parser = argparse.ArgumentParser(description="Scraper SeLoger avec Supabase")
    parser.add_argument("--supabase-url", help="URL Supabase")
    parser.add_argument("--supabase-key", help="Cl√© API Supabase")
    parser.add_argument("--headless", action="store_true", default=True, help="Mode invisible (d√©faut: activ√©)")
    parser.add_argument("--visible", action="store_false", dest="headless", help="Mode visible")
    
    args = parser.parse_args()
    
    driver = None
    supabase_manager = None
    
    try:
        logger.info("üé¨ D√©marrage du script SeLoger complet...")
        
        # Initialiser Supabase si les param√®tres sont fournis
        if args.supabase_url and args.supabase_key:
            logger.info("üìä Initialisation de Supabase...")
            supabase_manager = SupabaseManager(args.supabase_url, args.supabase_key)
            
            # Cr√©er une campagne de recherche
            search_config = {
                'ville': 'saumur',
                'type_bien': 'tous',
                'type_transaction': 'vente'
            }
            search_url = "https://www.seloger.com/list.htm?tri=initial&naturebien=1,2,4&idtt=2&idtypebien=1,2&ci=490328"
            supabase_manager.create_search_campaign(search_config, search_url)
        
        # Configuration du driver
        driver = setup_driver(headless=args.headless)
        if not driver:
            logger.error("‚ùå Impossible de configurer le driver")
            return
        
        # Aller sur SeLoger
        logger.info("üåê Navigation vers SeLoger...")
        driver.get("https://www.seloger.com")
        
        # Charger les cookies
        logger.info("üç™ Chargement des cookies...")
        load_cookies(driver, "cookies seloger.txt")
        
        # Recharger la page avec les cookies
        logger.info("üîÑ Rechargement de la page avec les cookies...")
        driver.refresh()
        time.sleep(0.5)  # Minimal pour le chargement
        
        # G√©rer la banni√®re de cookies
        handle_cookie_banner(driver)
        
        # G√©rer les pop-ups d'alerte qui peuvent appara√Ætre
        handle_alert_popup(driver)
        
        # Rechercher Saumur
        if search_saumur(driver):
            logger.info("üéØ Recherche de Saumur r√©ussie")
            
            # Attendre les r√©sultats
            if wait_for_results(driver):
                logger.info("‚úÖ R√©sultats de recherche charg√©s")
                
                # G√©rer une √©ventuelle pop-up d'alerte apr√®s le chargement des r√©sultats
                handle_alert_popup(driver)
                
                # Navigation par pagination et r√©cup√©ration des annonces
                listings = scroll_and_collect_listings(driver)  # Toutes les pages disponibles
                
                if listings:
                    # Sauvegarder les annonces en local
                    save_listings_to_file(listings)
                    
                    # Envoyer vers Supabase si configur√©
                    if supabase_manager and supabase_manager.supabase:
                        logger.info("üîó Envoi vers Supabase...")
                        supabase_manager.send_listings_to_supabase(listings)
                        supabase_manager.update_campaign_status('completed', total_listings=len(listings))
                    
                    # Afficher un r√©sum√©
                    logger.info("üìã R√©sum√© des annonces r√©cup√©r√©es:")
                    for i, listing in enumerate(listings[:5], 1):  # Afficher les 5 premi√®res
                        logger.info(f"   {i}. ID: {listing.get('id', 'Sans ID')} - URL: {listing.get('url', 'Sans URL')[:80]}...")
                    
                    if len(listings) > 5:
                        logger.info(f"   ... et {len(listings) - 5} autres annonces")
                    
                    logger.info("üéâ ‚úÖ Script termin√© avec succ√®s!")
                else:
                    logger.warning("‚ö†Ô∏è Aucune annonce r√©cup√©r√©e")
                    if supabase_manager and supabase_manager.supabase:
                        supabase_manager.update_campaign_status('completed', total_listings=0)
            else:
                logger.warning("‚ö†Ô∏è R√©sultats non charg√©s dans les temps")
                if supabase_manager and supabase_manager.supabase:
                    supabase_manager.update_campaign_status('failed')
        else:
            logger.error("‚ùå √âchec de la recherche de Saumur")
            if supabase_manager and supabase_manager.supabase:
                supabase_manager.update_campaign_status('failed')
        
    except Exception as e:
        logger.error(f"Erreur dans le script principal: {e}")
        if supabase_manager and supabase_manager.supabase:
            supabase_manager.update_campaign_status('failed')
    finally:
        if driver:
            try:
                driver.quit()
                logger.info("üîö Navigateur ferm√©")
            except:
                pass

if __name__ == "__main__":
    main() 